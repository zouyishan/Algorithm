最初始的时候：i == j ，dp[i][j] = 0，因为删了之后没得取

当 `j - i == 1` 时，`dp[i][j] = max(stones[i], stones[j])`，因为我要利益最大化，我肯定删掉一个较小的石头，取最大得分，反正下一个人是没分的

当 `j - i > 1` 时， `dp[i][j] = max(sum[i + 1][j] - dp[i + 1][j], sum[i][j - 1] - dp[i][j - 1])`

```
class Solution {
public:
    int stoneGameVII(vector<int>& stones) {
		int n = stones.size();
		vector<vector<int>> sum(n, vector<int>(n, 0));
		for(int i = 0; i < n; i++){
			for(int j = i; j < n; j++){
				if(i == j) sum[i][j] = stones[i]; //记录区间和
				else sum[i][j] = stones[j] + sum[i][j - 1];
			}
		}
		vector<vector<int>> dp(n, vector<int>(n, 0));
		for(int i = n - 1; i >= 0; i--){
			for(int j = i + 1; j < n; j++){
				if(j - i == 1) dp[i][j] = max(stones[i], stones[j]);  //状态转移方程
				else dp[i][j] = max(sum[i + 1][j] - dp[i + 1][j], sum[i][j - 1] - dp[i][j - 1]);
			}
		}
		return dp[0][n - 1]; //返回A能取的最大和
    }
};
```
