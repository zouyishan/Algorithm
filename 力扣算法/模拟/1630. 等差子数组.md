题目链接：https://leetcode-cn.com/problems/arithmetic-subarrays/

快排应用：

```cpp
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
void quickSort(int* nums,int left,int right)
{
    if(left<right)//如果数组左边界小于右边界则进行排序
    {
        int x=nums[right];
        int temp;
        int i=left-1;
        for(int j=left;j<right;j++)//把小于等于x的放在数组左边
        {
            if(nums[j]<=x)
            {
                i++;
                temp=nums[i];
                nums[i]=nums[j];
                nums[j]=temp;
            }
        }
        temp=nums[i+1];
        nums[i+1]=nums[right];
        nums[right]=temp;//此时数组第i+1个位置是x，即i+1之前的元素小于等于x，i+1之后的大于x
        quickSort(nums,left,i);//对i+1左边的数组进行排序
        quickSort(nums,i+2,right);//对i+1右边的数组进行排序
    }
}

bool isCheck(int* nums,int len)//判断是否是等差数列
{
    if(len==2)
        return true;
    if(len<2)
        return false;
    int minus=nums[1]-nums[0];
    for(int i=0;i+1<len;i++)
        if((nums[i+1]-nums[i])!=minus)
            return false;
    return true;
}

bool* checkArithmeticSubarrays(int* nums, int numsSize, int* l, int lSize, int* r, int rSize, int* returnSize){
    *returnSize=0;
    if(numsSize<2||lSize==0||rSize==0)
        return NULL;

    bool* res=(bool*)malloc(sizeof(bool)*1000);

    for(int i=0;i<lSize;i++)
    {
        int left=l[i];//左边界
        int right=r[i];//右边界
        int temp[right-left+1];//用临时数组保存区间内的元素

        for(int j=left;j<=right;j++)
            temp[j-left]=nums[j];

        quickSort(temp,0,right-left);

        if(isCheck(temp,right-left+1))
            res[(*returnSize)++]=true;
        else
            res[(*returnSize)++]=false;
    }
    return res;
}

```
